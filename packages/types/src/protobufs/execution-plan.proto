syntax = "proto3";

package flow_like_types;

import "board.proto";
import "pin.proto";
import "variable.proto";

// Performance-oriented representation of a board as a dense, index-based execution plan.
//
// Design goals:
// - No string-keyed maps required during execution
// - Contiguous arrays for cache locality
// - Flattened adjacency lists (CSR-like) for fast traversal
//
// Notes:
// - `symbols` is optional but recommended. It interns strings (node type keys, debug names).
// - Values are stored as bytes (typically canonical JSON) so this proto stays runtime-agnostic.
//   A high-performance runtime can decode lazily or use a compact typed encoding.

message ExecutionPlan {
  // Identity
  string board_id = 1;
  uint32 version_major = 2;
  uint32 version_minor = 3;
  uint32 version_patch = 4;
  ExecutionStage stage = 5;
  LogLevel log_level = 6;

  // Optional interned strings; indices are used throughout the plan.
  repeated string symbols = 10;

  // Tables
  repeated PlanNode nodes = 20;
  repeated PlanPin pins = 21;
  repeated PlanVariable variables = 22;

  // ---- Exec graph (node -> successor nodes) ---------------------------------
  // CSR layout: successors for node i are in exec_succ_nodes[exec_succ_offsets[i] .. exec_succ_offsets[i+1])
  repeated uint32 exec_succ_offsets = 30;
  repeated uint32 exec_succ_nodes = 31;

  // Reserved: these previously held redundant ready-queue metadata.
  // Store only exec successors to keep the plan minimal; derive in-degree at load time.
  reserved 32, 33, 34;

  // ---- Data edges (pin -> connected pins) -----------------------------------
  // CSR layout: connected pins for pin i are in pin_conn_pins[pin_conn_offsets[i] .. pin_conn_offsets[i+1])
  repeated uint32 pin_conn_offsets = 40;
  repeated uint32 pin_conn_pins = 41;

  // ---- Dependency edges (pin -> depends_on pins) ----------------------------
  // CSR layout: dependencies for pin i are in pin_dep_pins[pin_dep_offsets[i] .. pin_dep_offsets[i+1])
  repeated uint32 pin_dep_offsets = 50;
  repeated uint32 pin_dep_pins = 51;

  // Entry node for execution (index into nodes)
  uint32 entry_node = 60;
}

message PlanNode {
  // The board instance node id can be stored as a symbol for debugging. Not required at runtime.
  uint32 instance_id_symbol = 1;

  // Node type key used to resolve NodeLogic (e.g. "events_simple", "math_add").
  uint32 type_key_symbol = 2;

  // Cached purity for scheduling / memoization.
  bool is_pure = 3;

  // Pin range for this node within `ExecutionPlan.pins`.
  uint32 first_pin = 4;
  uint32 pin_count = 5;
}

message PlanPin {
  // Debug name (symbol). Runtime should use index-based access instead.
  uint32 name_symbol = 1;

  // Owner node index, or UINT32_MAX for non-node pins (e.g. layer relay pins).
  uint32 owner_node = 2;

  // Type information
  PinType pin_type = 3;
  VariableType data_type = 4;
  ValueType value_type = 5;

  // Default value (canonical bytes, typically JSON)
  bytes default_value = 6;

  // Stable ordering index (copied from pin index)
  uint32 index = 7;
}

message PlanVariable {
  uint32 id_symbol = 1;
  VariableType data_type = 2;
  ValueType value_type = 3;

  bool exposed = 4;
  bool secret = 5;
  bool editable = 6;

  bytes default_value = 7;
}
