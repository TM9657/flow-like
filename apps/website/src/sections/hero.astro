---
import { EmptyBackendProvider } from "../components/backend-provider";

const github = "https://github.com/TM9657/flow-like";
const docs = "https://docs.flow-like.com";
---

<section class="relative py-8 md:py-12 lg:py-16 max-w-screen overflow-hidden">
    <div
        id="hero-connection-layer"
        class="pointer-events-none absolute inset-0 w-full h-full -z-1 overflow-hidden contain-[layout_paint]"
    >
        <svg
            id="hero-connections"
            class="hidden lg:block absolute inset-0"
            style="overflow:visible;width:100%"
            aria-hidden="true"
        >
            <path id="hero-right-conn" class="pin-conn text-primary" fill="none"
            ></path>
            <path
                id="hero-left-conn"
                class="pin-conn text-emerald-500"
                fill="none"></path>
            <path
                id="hero-right-conn-top"
                class="pin-conn-solid text-foreground/40"
                fill="none"></path>
            <path
                id="hero-left-conn-top"
                class="pin-conn-solid text-foreground/40"
                fill="none"></path>
        </svg>
    </div>
    <div id="hero-cover" class="mx-auto max-w-7xl px-4 lg:px-8 relative">
        <!-- pin anchors - only on large screens -->
        <div
            id="hero-right-pin"
            class="hidden lg:block size-2.5 bg-primary absolute top-48 right-4 lg:right-8 rounded-full z-10 pointer-events-none"
        >
        </div>
        <div
            id="hero-left-pin"
            class="hidden lg:block size-2.5 bg-emerald-500 absolute top-28 left-4 lg:left-8 rounded-full z-10 pointer-events-none"
        >
        </div>
        <div
            id="hero-right-pin-top"
            class="hidden lg:block size-2.5 bg-foreground/50 absolute top-8 right-4 lg:right-8 rounded-full z-10 pointer-events-none"
        >
        </div>
        <div
            id="hero-left-pin-top"
            class="hidden lg:block size-2.5 bg-foreground/50 absolute top-8 left-4 lg:left-8 rounded-full z-10 pointer-events-none"
        >
        </div>

        <div
            class="hero-card relative overflow-hidden rounded-2xl border border-border/50 bg-background/90 backdrop-blur-sm shadow-2xl shadow-black/20"
        >
            <!-- Subtle gradient overlay -->
            <div class="absolute inset-0 bg-linear-to-br from-primary/2 via-transparent to-emerald-500/2 pointer-events-none"></div>

            <div class="relative grid lg:grid-cols-2 gap-0">
                <!-- Left: Content -->
                <div class="p-8 sm:p-10 lg:p-12 xl:p-14 flex flex-col justify-center reveal order-2 lg:order-1">
                    <p class="text-[10px] sm:text-[11px] font-medium tracking-[0.25em] uppercase text-muted-foreground/70 mb-6">
                        Model Â· Automate Â· Scale
                    </p>

                    <h1 class="text-3xl sm:text-4xl lg:text-[2.75rem] xl:text-5xl font-bold tracking-tight leading-[1.1] mb-5">
                        Automate your work â€” see the full data story
                    </h1>

                    <p class="text-base sm:text-lg text-muted-foreground leading-relaxed mb-8 max-w-xl">
                        Flow-Like is a visual workflow tool. Build with drag-and-drop blocks, and get a clear record of where data came from, what changed, and why â€” no black boxes.
                    </p>

                    <div class="flex flex-wrap items-center gap-3 mb-8">
                        <a
                            href="/download"
                            class="inline-flex items-center justify-center rounded-full bg-foreground text-background px-6 py-3 text-sm font-medium hover:bg-foreground/90 transition-all hover:scale-[1.02] active:scale-[0.98]"
                            >Download</a
                        >
                        <a
                            href={docs}
                            class="inline-flex items-center justify-center rounded-full border border-border/80 bg-background/50 px-6 py-3 text-sm font-medium text-foreground hover:bg-muted/50 hover:border-border transition-colors"
                            >Explore docs</a
                        >
                        <a
                            href={github}
                            class="hidden sm:inline-flex items-center gap-1 text-sm font-medium text-muted-foreground hover:text-foreground transition-colors group"
                            >Star on GitHub <span class="group-hover:translate-x-0.5 transition-transform">â†’</span></a
                        >
                    </div>

                    <div class="flex flex-wrap items-center gap-2">
                        <span class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs rounded-full border border-border/40 text-muted-foreground bg-muted/10">
                            ðŸ§© Drag-and-drop
                        </span>
                        <span class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs rounded-full border border-border/40 text-muted-foreground bg-muted/10">
                            ðŸ”’ Private by default
                        </span>
                        <span class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs rounded-full border border-border/40 text-muted-foreground bg-muted/10">
                            âš¡ Rust-fast
                        </span>
                    </div>
                </div>

                <!-- Right: Node Graph (smaller, more embedded) -->
                <div class="relative min-h-[200px] sm:min-h-60 lg:min-h-[340px] reveal order-1 lg:order-2 border-b lg:border-b-0 lg:border-l border-border/30">
                    <EmptyBackendProvider data="/board.json" client:idle />
                    <div
                        aria-hidden="true"
                        class="pointer-events-none absolute bottom-3 right-3 flex gap-1.5"
                    >
                        <span class="text-[9px] sm:text-[10px] px-2 py-0.5 rounded bg-background/70 backdrop-blur-sm border border-border/30 text-muted-foreground/70">Node Graph</span>
                        <span class="text-[9px] sm:text-[10px] px-2 py-0.5 rounded bg-emerald-500/10 border border-emerald-500/20 text-emerald-500">Live</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<style>
    .pin-conn-solid {
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        vector-effect: non-scaling-stroke;
    }
    .pin-conn {
        stroke: currentColor;
        stroke-width: 3;
        stroke-linecap: round;
        stroke-linejoin: round;
        vector-effect: non-scaling-stroke;
        stroke-dasharray: 6 8;
        animation: flow-dots 1.2s linear infinite;
    }
    @keyframes flow-dots {
        to {
            stroke-dashoffset: -14px;
        }
    }
    .reveal {
        opacity: 0;
        transform: translateY(6px);
    }
    .reveal.is-visible {
        opacity: 1;
        transform: none;
        transition:
            opacity 0.5s ease,
            transform 0.5s ease;
    }
    @media (prefers-reduced-motion: reduce) {
        .reveal {
            transition: none !important;
            transform: none !important;
        }
        .pin-conn {
            animation: none !important;
        }
    }
</style>

<script>
    const $ = (s: string, r = document) => r.querySelector(s);

    const heroEl = document.getElementById("hero-cover");
    const sectionEl =
        document.currentScript?.closest("section") ||
        document.querySelector("section.relative");
    const layer = document.getElementById("hero-connection-layer");
    const svg = document.getElementById("hero-connections");
    const rp = document.getElementById("hero-right-pin");
    const lp = document.getElementById("hero-left-pin");
    const rpt = document.getElementById("hero-right-pin-top");
    const lpt = document.getElementById("hero-left-pin-top");

    // Calibration (tweak if still off):
    const CAL_LEFT_X = 0; // positive moves paths right
    const CAL_RIGHT_X = 0; // positive moves paths right
    const setSvgFrame = () => {
        if (!heroEl || !svg || !layer) return;
        const hr = heroEl.getBoundingClientRect();
        const secRect = sectionEl?.getBoundingClientRect();
        const containerWidth = secRect?.width || window.innerWidth;
        const h = hr.height;
        layer.style.height = `${h}px`; // width inherited (no manual setting -> prevents 100vw rounding overflow)
        svg.style.width = "100%"; // responsive to container
        svg.setAttribute("viewBox", `0 0 ${containerWidth} ${h}`);
        svg.setAttribute("width", String(containerWidth));
        svg.setAttribute("height", String(h));
    };

    const bezier = (pin: HTMLElement, isRight: boolean, yOffset = 60) => {
        const baseRect = sectionEl?.getBoundingClientRect() ||
            heroEl?.getBoundingClientRect() || {
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                right: 0,
            };
        const pr = pin.getBoundingClientRect();
        const layerRect = layer?.getBoundingClientRect();
        const layerLeft = layerRect ? layerRect.left : 0;
        let sx = pr.left - layerLeft + pr.width / 2;
        sx += isRight ? CAL_RIGHT_X : CAL_LEFT_X;
        const sy = pr.top - baseRect.top + pr.height / 2;

        const isMobile = window.innerWidth < 768;
        const extra = isMobile ? 0 : 220;
        const vw = Math.max(
            document.documentElement.clientWidth,
            window.innerWidth || 0,
        );

        // Extend beyond screen edges for pleasant overshoot
        const ex = isRight ? vw + extra : -extra;
        const ey = sy + (isRight ? yOffset : yOffset * 1.35);

        const dx = ex - sx;
        const cp1x = sx + dx * 0.42;
        const cp2x = sx + dx * 0.82;
        return `M${sx},${sy} C${cp1x},${sy} ${cp2x},${ey} ${ex},${ey}`;
    };

    const quad = (pin: HTMLElement, isRight: boolean, yOffset = -20) => {
        const baseRect = sectionEl?.getBoundingClientRect() ||
            heroEl?.getBoundingClientRect() || {
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                right: 0,
            };
        const pr = pin.getBoundingClientRect();
        const layerRect = layer?.getBoundingClientRect();
        const layerLeft = layerRect ? layerRect.left : 0;
        let sx = pr.left - layerLeft + pr.width / 2;
        sx += isRight ? CAL_RIGHT_X : CAL_LEFT_X;
        const sy = pr.top - baseRect.top + pr.height / 2;

        const isMobile = window.innerWidth < 768;
        const extra = isMobile ? 0 : 300; // remove overshoot on mobile
        const vw = Math.max(
            document.documentElement.clientWidth,
            window.innerWidth || 0,
        );

        const ex = isRight ? vw + extra : -extra;
        const ey = sy + (isRight ? yOffset : -yOffset);
        const cp1x = sx + (ex - sx) * 0.6;
        return `M${sx},${sy} Q${cp1x},${sy} ${ex},${ey}`;
    };

    const updatePaths = () => {
        if (!heroEl || !svg) return;
        setSvgFrame();
        const rc = $("#hero-right-conn");
        const lc = $("#hero-left-conn");
        const rct = $("#hero-right-conn-top");
        const lct = $("#hero-left-conn-top");
        if (rp && rc) rc.setAttribute("d", bezier(rp, true));
        if (lp && lc) lc.setAttribute("d", bezier(lp, false, 80));
        if (rpt && rct) rct.setAttribute("d", quad(rpt, true));
        if (lpt && lct) lct.setAttribute("d", quad(lpt, false));
    };

    const revealEls = Array.from(document.querySelectorAll(".reveal"));
    const io: any =
        "IntersectionObserver" in window
            ? new IntersectionObserver(
                  (entries) => {
                      for (const e of entries)
                          if (e.isIntersecting) {
                              e.target.classList.add("is-visible");
                              io.unobserve(e.target);
                          }
                  },
                  { rootMargin: "0px 0px -10% 0px", threshold: 0.15 },
              )
            : null;
    if (io) revealEls.forEach((el) => io.observe(el));
    else revealEls.forEach((el) => el.classList.add("is-visible"));

    const raf = (fn: FrameRequestCallback) => requestAnimationFrame(fn);
    addEventListener("resize", () => raf(updatePaths));
    // Include scroll updates so vertical offset stays correct when page is scrolled before images/fonts settle.
    addEventListener("scroll", () => raf(updatePaths), { passive: true });
    addEventListener("load", () => raf(updatePaths));
    setTimeout(() => raf(updatePaths), 50);

    if (window.ResizeObserver && heroEl) {
        const ro = new ResizeObserver(() => raf(updatePaths));
        ro.observe(heroEl);
    }
</script>
